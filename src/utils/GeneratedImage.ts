import p5Utils, {P5Image} from "./p5Utils";
import wrap, {ImageConvertOptions} from "./imageConversion";
import {Tensor} from "@tensorflow/tfjs";

/**
 * Object for an image generated by TensorFlow.
 *
 * Used in models including: CartoonGAN, DCGAN, UNET, BodyPix, CVAE, etc.
 */

export interface GeneratedImageResult {
    raw: ImageData;
    src: string; // TODO: can this be removed?
    blob: Blob;
    tensor?: Tensor;
    image: P5Image | HTMLCanvasElement;
}

export interface GeneratedImageOptions extends ImageConvertOptions {
    /**
     * If true, include a `tensors` property in the result.
     * Default: false
     */
    returnTensors?: boolean;
}

/**
 * TODO: could improve performance by using getters to create formats on demand instead of generating all at once.
 *
 * Takes a Tensor and returns an object containing multiple formats.
 * Will dispose of the Tensor if not returning the tensor.
 * Accepts settings as an object so that models can pass this.config.
 *
 * Note: Will only work with a rank-3 Tensor (Tensor3D / Tensor<Rank.R3>).
 * Function accepts general `Tensor` type because the rank gets lost when performing operations.
 * Will throw an error on incorrect rank.
 *
 * @param tensor
 * @param settings
 */
export const generatedImageResult = async (tensor: Tensor, settings: GeneratedImageOptions = {}): Promise<GeneratedImageResult> => {
    const converter = wrap(tensor, settings);
    const {returnTensors = false} = settings;
    const raw = await converter.toData();
    const src = await converter.toDataUrl();
    const blob = await converter.toBlob();
    const canvas = await converter.toCanvas();

    let p5Image;
    if (p5Utils.checkP5()) {
        try {
            p5Image = p5Utils.fromPixels(raw);
        } catch (e) {
            // catch and return canvas
        }
    }
    const image = p5Image || canvas;

    if ( returnTensors ) {
        return {src, raw, image, tensor, blob};
    } else {
        tensor.dispose();
        return {src, raw, image, blob};
    }
}

type GroupedResult<Keys extends string> = {
    [K in keyof GeneratedImageResult]: Record<Keys, GeneratedImageResult[K]> | ( GeneratedImageResult[K] extends undefined ? undefined : never )
}

const formats: (keyof GeneratedImageResult)[] = ['src', 'raw', 'image', 'tensor', 'blob'];

type Entry<T> = {
    [K in keyof T]: [K, T[K]];
}[keyof T]

export const typedEntries = <T extends object>(obj: T) => Object.entries(obj) as Entry<T>[];

/**
 * Returns various masks/images sorted by type
 * @param tensorMap
 * @param settings
 */
export const groupedResult = async <Keys extends string>(tensorMap: Record<Keys, Tensor>, settings?: GeneratedImageOptions): Promise<GroupedResult<Keys>> => {
    const properties = Object.keys(tensorMap) as Keys[];
    const results = await Promise.all(Object.values<Tensor>(tensorMap)
        .map(tensor => generatedImageResult(tensor, settings)));
    return formats.reduce((result, format) => {
        // dictionary of properties (ie. "backgroundMask) and values for this format (ie "raw")
        const group = properties.reduce((obj, property, i) => ({
            ...obj,
            [property]: results[i][format]
        }), {});
        // add this dictionary to the result which is grouped by format
        return {
            ...result,
            [format]: group
        }
    }, {}) as GroupedResult<Keys>;
}